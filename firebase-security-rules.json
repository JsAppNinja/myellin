{
  "rules": {
    "outcomes": {
      ".indexOn": ["slug"],
      ".read": true,
      "$outcome": {
        
          /* Only admins can create outcomes. Non-admins can increment or de-increment an existing playlist_count field by 1.
             We're using .validate instead of .write for "playlist_count" and "$other_fields" because Firebase ...
             ... won't let use write an object to "$outcome" without a .write rule there that equals true.
             So we use .validate, which cascades, allowing us to limit non-admin writes to just the "playlist_count" field.
             Normally we'd only want to use .validate for actual data validation. */
          
          ".write": "auth != null", // Must be logged in
          
          // Can only write if admin or changing value by 1 (happens on creation and deletion of a playlist)
          "playlist_count": {
            ".validate": "root.child('users/' + auth.uid + '/admin').val() === true ||
                          (data.exists() && newData.val() === data.val() + 1) ||
                          (data.exists() && newData.val() === data.val() - 1)"
          },
          
          // All other fields can only be written by admins
         "$other": {
           ".validate": "root.child('users/' + auth.uid + '/admin').val() === true"
         }
      }  
    },
    "relations": {
      ".read": true,
      "section_to_outcome": {
        "home": {
          "$outcome": {
            // Must be an admin to add an outcome to the homepage
            ".write": "auth != null && root.child('users/' + auth.uid + '/admin').val() === true"
          }
        }
      },
      // Other paths are writeable by anyone for now
      "$other": {
        ".write": true
      }
    },
    "playlists": {
      ".read": true,
      ".write": true,
      "$playlist": {
        ".write": true
      }
    },
    "options": {
      ".read": true,
      "$option": {
          // Must be logged in AND either creating new data or updating existing data belonging to you
         ".write": "auth != null && 
                      (!data.exists() || data.child('author_id').val() == auth.uid)",
          // Must include required children, author_id must match auth.id, and description must be a string
         ".validate": "newData.hasChildren(['author_id', 'description']) && 
                        newData.child('author_id').val() == auth.uid && 
                          newData.child('description').isString()"
      }
    },
    "suboutcomes": {
      ".read": true,
      "$suboutcome": {

          ".write": "auth != null", // Must be logged in
          
          "option_count": {
            ".validate": "(!data.parent().exists() && newData.val() === 0) || // If suboutcome is being created, option_count must be 0
                          (data.exists() && newData.val() === data.val() + 1) || // If data exists already only allow increment
                          (data.exists() && newData.val() === data.val() - 1)" // And de-increment
          },
          
          // All other fields can only be written only if suboutcome is new OR if user is author
         "$other": {
           ".validate": "!data.parent().exists() || // Allow write if suboutcome is new
                            data.parent().child('author_id').val() === auth.uid" // Or if user is author
         }
      }
    },
    "users": {
      ".read": true,
      ".write": true
    },
    "upvotes": {
      ".read": true,
      ".write": true
    }
  }
}